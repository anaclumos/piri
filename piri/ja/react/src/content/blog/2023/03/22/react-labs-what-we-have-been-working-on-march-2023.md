---
title: React ラボ: 私たちが取り組んでいたこと – 2023年3月
author: Joseph Savona, Josh Story, Lauren Tan, Mengdi Chen, Samuel Susla, Sathya Gunasekaran, Sebastian Markbage, and Andrew Clark
date: 2023/03/22
description: React Labsの投稿では、現在研究開発中のプロジェクトについて書いています。前回の更新以来、これらのプロジェクトで大きな進展がありましたので、学んだことを共有したいと思います。
---

2023年3月22日 [Joseph Savona](https://twitter.com/en_JS)、[Josh Story](https://twitter.com/joshcstory)、[Lauren Tan](https://twitter.com/potetotes)、[Mengdi Chen](https://twitter.com/mengdi_en)、[Samuel Susla](https://twitter.com/SamuelSusla)、[Sathya Gunasekaran](https://twitter.com/_gsathya)、[Sebastian Markbåge](https://twitter.com/sebmarkbage)、および [Andrew Clark](https://twitter.com/acdlite)

---

<Intro>

React Labsの投稿では、現在進行中の研究開発プロジェクトについて書いています。前回の[更新](/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022)以来、これらのプロジェクトで大きな進展があり、その学びを共有したいと思います。

</Intro>

---

## React Server Components {/*react-server-components*/}

React Server Components（またはRSC）は、Reactチームによって設計された新しいアプリケーションアーキテクチャです。

RSCに関する研究を最初に共有したのは、[紹介トーク](/blog/2020/12/21/data-fetching-with-react-server-components)と[RFC](https://github.com/reactjs/rfcs/pull/188)でした。それらを要約すると、事前に実行され、JavaScriptバンドルから除外される新しい種類のコンポーネントであるServer Componentsを導入しています。Server Componentsはビルド中に実行され、ファイルシステムから読み取ったり、静的コンテンツをフェッチしたりできます。また、サーバー上で実行され、APIを構築することなくデータレイヤーにアクセスできます。Server ComponentsからブラウザのインタラクティブなClient Componentsにプロップスを介してデータを渡すことができます。

RSCは、サーバー中心のマルチページアプリのシンプルな「リクエスト/レスポンス」メンタルモデルと、クライアント中心のシングルページアプリのシームレスなインタラクティビティを組み合わせ、両方の利点を提供します。

前回の更新以来、[React Server Components RFC](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md)をマージして提案を正式に承認しました。[React Server Module Conventions](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md)提案の未解決の問題を解決し、パートナーと合意して「"use client"」の規約を採用しました。これらの文書は、RSC互換の実装がサポートすべき仕様としても機能します。

最大の変更点は、Server Componentsからデータをフェッチするための主要な方法として[`async` / `await`](https://github.com/reactjs/rfcs/pull/229)を導入したことです。また、Promiseをアンラップする新しいフック`use`を導入して、クライアントからのデータロードをサポートする予定です。クライアント専用のアプリでは任意のコンポーネントで`async / await`をサポートすることはできませんが、RSCアプリと同様の構造にすることでサポートを追加する予定です。

データフェッチがかなり整理されたので、次の方向性として、クライアントからサーバーにデータを送信することを検討しています。これにより、データベースの変更を実行し、フォームを実装できるようになります。これを実現するために、サーバー/クライアントの境界を越えてServer Action関数を渡し、クライアントがそれを呼び出すことでシームレスなRPCを提供します。Server Actionsは、JavaScriptが読み込まれる前に段階的に強化されたフォームも提供します。

React Server Componentsは[Next.js App Router](/learn/start-a-new-react-project#nextjs-app-router)に搭載されています。これは、RSCをプリミティブとして本当に取り入れたルーターの深い統合を示していますが、RSC互換のルーターとフレームワークを構築する唯一の方法ではありません。RSC仕様と実装が提供する機能には明確な分離があります。React Server Componentsは、互換性のあるReactフレームワーク全体で機能するコンポーネントの仕様として意図されています。

一般的には既存のフレームワークを使用することをお勧めしますが、独自のカスタムフレームワークを構築することも可能です。RSC互換のフレームワークを構築するのは、必要な深いバンドラー統合のため、思ったほど簡単ではありません。現在のバンドラーの世代はクライアントでの使用には優れていますが、サーバーとクライアントの間で単一のモジュールグラフを分割するための一級のサポートを念頭に置いて設計されていません。これが、RSCのプリミティブを組み込むためにバンドラー開発者と直接協力している理由です。

## Asset Loading {/*asset-loading*/}

[Suspense](/reference/react/Suspense)は、コンポーネントのデータやコードがまだ読み込まれている間に画面に表示する内容を指定できます。これにより、ページの読み込み中やルーターのナビゲーション中にユーザーが徐々に多くのコンテンツを見ることができます。しかし、ユーザーの視点から見ると、新しいコンテンツが準備完了かどうかを判断する際に、データの読み込みとレンダリングだけでは全体像を伝えきれません。デフォルトでは、ブラウザはスタイルシート、フォント、画像を独立して読み込むため、UIのジャンプや連続的なレイアウトシフトが発生する可能性があります。

Reactは、スタイルシート、フォント、画像の読み込みライフサイクルと完全に統合するために取り組んでおり、それらを考慮してコンテンツが表示準備が整っているかどうかを判断します。Reactコンポーネントの作成方法を変更することなく、更新はより一貫性があり、心地よい動作をします。最適化として、フォントなどのアセットをコンポーネントから直接プリロードする手動の方法も提供します。

これらの機能を現在実装中で、近日中にさらに詳細を共有する予定です。

## Document Metadata {/*document-metadata*/}

アプリの異なるページや画面には、特定の画面に固有の`<title>`タグ、説明、およびその他の`<meta>`タグなどの異なるメタデータが含まれている場合があります。メンテナンスの観点からは、この情報をそのページや画面のReactコンポーネントの近くに保持する方がスケーラブルです。しかし、このメタデータのHTMLタグは、通常アプリの最上位のコンポーネントでレンダリングされるドキュメントの`<head>`にある必要があります。

今日では、この問題を解決するために2つの技術のいずれかを使用しています。

1つの技術は、`<title>`、`<meta>`、およびその他のタグをドキュメントの`<head>`に移動する特別なサードパーティコンポーネントをレンダリングすることです。これは主要なブラウザでは機能しますが、Open GraphパーサーなどのクライアントサイドJavaScriptを実行しない多くのクライアントには適していません。

もう1つの技術は、ページを2つの部分に分けてサーバーレンダリングすることです。まず、メインコンテンツをレンダリングし、すべてのタグを収集します。次に、これらのタグを使用して`<head>`をレンダリングします。最後に、`<head>`とメインコンテンツをブラウザに送信します。このアプローチは機能しますが、[React 18のストリーミングサーバーレンダラー](/reference/react-dom/server/renderToReadableStream)を利用することができません。すべてのコンテンツがレンダリングされるまで待つ必要があるためです。

このため、コンポーネントツリーのどこにでも`<title>`、`<meta>`、およびメタデータ`<link>`タグをレンダリングするための組み込みサポートを追加しています。これは、完全にクライアントサイドのコード、SSR、および将来的にはRSCを含むすべての環境で同じように機能します。近日中にさらに詳細を共有する予定です。

## React Optimizing Compiler {/*react-optimizing-compiler*/}

前回の更新以来、[React Forget](/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022#react-compiler)の設計を積極的に繰り返しています。これはReactの最適化コンパイラです。以前は「自動メモ化コンパイラ」として話していましたが、ある意味ではそれは真実です。しかし、コンパイラを構築することで、Reactのプログラミングモデルをさらに深く理解することができました。React Forgetを理解するためのより良い方法は、自動的な*リアクティビティ*コンパイラとして理解することです。

Reactのコアアイデアは、開発者が現在の状態の関数としてUIを定義することです。開発者は、数値、文字列、配列、オブジェクトなどのプレーンなJavaScript値を使用し、if/else、forなどの標準的なJavaScriptのイディオムを使用してコンポーネントロジックを記述します。メンタルモデルは、アプリケーションの状態が変わるたびにReactが再レンダリングするというものです。このシンプルなメンタルモデルとJavaScriptのセマンティクスに近づけることは、Reactのプログラミングモデルにおいて重要な原則であると考えています。

問題は、Reactが時々*過剰に*リアクティブになることです。たとえば、JavaScriptでは2つのオブジェクトや配列が同等かどうかを比較する安価な方法がないため、各レンダリングで新しいオブジェクトや配列を作成すると、Reactが必要以上に多くの作業を行う可能性があります。これにより、開発者は変更に過剰に反応しないようにコンポーネントを明示的にメモ化する必要があります。

React Forgetの目標は、Reactアプリがデフォルトで適切な量のリアクティビティを持つようにすることです。つまり、状態値が*意味的に*変化したときにのみアプリが再レンダリングされることです。実装の観点からは、これは自動的にメモ化することを意味しますが、リアクティビティのフレーミングはReactとForgetを理解するためのより良い方法であると考えています。現在のReactはオブジェクトの同一性が変わると再レンダリングしますが、Forgetでは、Reactは意味的な値が変わると再レンダリングしますが、深い比較のランタイムコストをかけずに行います。

具体的な進捗としては、前回の更新以来、この自動リアクティビティアプローチに合わせてコンパイラの設計を大幅に繰り返し、内部でコンパイラを使用したフィードバックを取り入れました。昨年末からコンパイラの大規模なリファクタリングを行った後、現在Metaの限られた領域でコンパイラを本番環境で使用し始めています。本番環境での検証が完了次第、オープンソース化する予定です。

最後に、多くの人々がコンパイラの動作に興味を持っています。コンパイラを証明し、オープンソース化する際に、さらに多くの詳細を共有することを楽しみにしています。しかし、今共有できるいくつかの点があります：

コンパイラのコアはBabelからほぼ完全に分離されており、コアコンパイラAPIは（大まかに言えば）古いASTを入力し、新しいASTを出力します（ソースロケーションデータを保持しながら）。内部では、低レベルのセマンティック分析を行うためにカスタムコード表現と変換パイプラインを使用しています。ただし、コンパイラの主な公開インターフェースはBabelおよびその他のビルドシステムプラグインを介して提供されます。テストの容易さのために、現在、各関数の新しいバージョンを生成し、それを入れ替えるコンパイラを呼び出す非常に薄いラッパーであるBabelプラグインを持っています。

過去数か月間にコンパイラをリファクタリングする際、条件文、ループ、再代入、および変更などの複雑さを処理できるようにコアコンパイルモデルを洗練することに焦点を当てました。しかし、JavaScriptにはそれらの機能を表現する多くの方法があります：if/else、三項演算子、for、for-in、for-ofなど。最初から完全な言語をサポートしようとすると、コアモデルを検証するポイントが遅れることになります。代わりに、言語の小さくても代表的なサブセットから始めました：let/const、if/else、forループ、オブジェクト、配列、プリミティブ、関数呼び出し、およびその他のいくつかの機能。コアモデルに自信を持ち、内部抽象化を洗練するにつれて、サポートされる言語サブセットを拡大しました。まだサポートされていない構文については明示的に診断を記録し、サポートされていない入力のコンパイルをスキップします。Metaのコードベースでコンパイラを試して、最も一般的なサポートされていない機能を確認し、次に優先するものを決定するためのユーティリティを持っています。言語全体をサポートする方向に向かって段階的に拡大し続けます。

Reactコンポーネント内のプレーンなJavaScriptをリアクティブにするには、コードが正確に何をしているのかを理解するためのセマンティクスの深い理解を持つコンパイラが必要です。このアプローチを取ることで、JavaScript内でのリアクティビティのシステムを作成し、特定のドメイン固有言語に制限されることなく、言語の完全な表現力を持つ任意の複雑さの製品コードを記述できるようにしています。

## Offscreen Rendering {/*offscreen-rendering*/}

Offscreen renderingは、追加のパフォーマンスオーバーヘッドなしにバックグラウンドで画面をレンダリングするためのReactの新しい機能です。これは、DOM要素だけでなくReactコンポーネントにも機能する[`content-visibility` CSSプロパティ](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility)のバージョンと考えることができます。研究中に、さまざまなユースケースを発見しました：

- ルーターはバックグラウンドで画面を事前レンダリングし、ユーザーがそれに移動するとすぐに利用可能になります。
- タブ切り替えコンポーネントは、非表示のタブの状態を保持し、ユーザーが進行状況を失うことなくタブを切り替えることができます。
- 仮想化リストコンポーネントは、表示ウィンドウの上下に追加の行を事前レンダリングできます。
- モーダルやポップアップを開くとき、アプリの残りの部分を「バックグラウンド」モードにして、モーダル以外のすべてのイベントと更新を無効にすることができます。

ほとんどのReact開発者は、Reactのoffscreen APIと直接対話することはありません。代わりに、offscreen renderingはルーターやUIライブラリに統合され、これらのライブラリを使用する開発者は追加の作業なしに自動的に恩恵を受けます。

アイデアは、コンポーネントの書き方を変更することなく、任意のReactツリーをオフスクリーンでレンダリングできるようにすることです。コンポーネントがオフスクリーンでレンダリングされると、そのコンポーネントは実際には*マウント*されず、コンポーネントが表示されるまでその効果は発動しません。たとえば、コンポーネントが初めて表示されるときに`useEffect`を使用して分析をログする場合、事前レンダリングはその分析の正確性を損なうことはありません。同様に、コンポーネントがオフスクリーンになると、その効果もアンマウントされます。オフスクリーンレンダリングの重要な機能は、コンポーネントの状態を失うことなくその可視性を切り替えることができることです。

前回の更新以来、AndroidおよびiOSのReact Nativeアプリで事前レンダリングの実験的バージョンを内部でテストし、ポジティブなパフォーマンス結果を得ました。また、Suspenseとの連携を改善し、オフスクリーンツリー内でのサスペンドがSuspenseフォールバックをトリガーしないようにしました。残りの作業は、ライブラリ開発者に公開されるプリミティブを最終化することです。今年後半にRFCを公開し、テストとフィードバックのための実験的APIを提供する予定です。

## Transition Tracing {/*transition-tracing*/}

Transition Tracing APIは、[React Transitions](/reference/react/useTransition)が遅くなるときにそれを検出し、なぜ遅くなるのかを調査することができます。前回の更新に続いて、APIの初期設計を完了し、[RFC](https://github.com/reactjs/rfcs/pull/238)を公開しました。基本的な機能も実装されています。このプロジェクトは現在保留中です。RFCに対するフィードバックを歓迎し、Reactのパフォーマンス測定ツールを提供するために開発を再開することを楽しみにしています。これは、[Next.js App Router](/learn/start-a-new-react-project#nextjs-app-router)のようなReact Transitions上に構築されたルーターに特に役立ちます。

* * *
この更新に加えて、私たちのチームは最近、コミュニティのポッドキャストやライブストリームにゲスト出演し、私たちの仕事について話し、質問に答えました。

* [Dan Abramov](https://twitter.com/dan_abramov)と[Joe Savona](https://twitter.com/en_JS)は、[Kent C. DoddsのYouTubeチャンネル](https://www.youtube.com/watch?v=h7tur48JSaw)でインタビューを受け、React Server Componentsに関する懸念について話しました。
* [Dan Abramov](https://twitter.com/dan_abramov)と[Joe Savona](https://twitter.com/en_JS)は、[JSPartyポッドキャスト](https://jsparty.fm/267)にゲスト出演し、Reactの将来についての考えを共有しました。

この投稿をレビューしてくれた[Andrew Clark](https://twitter.com/acdlite)、[Dan Abramov](https://twitter.com/dan_abramov)、[Dave McCabe](https://twitter.com/mcc_abe)、[Luna Wei](https://twitter.com/lunaleaps)、[Matt Carroll](https://twitter.com/mattcarrollcode)、[Sean Keegan](https://twitter.com/DevRelSean)、[Sebastian Silbermann](https://twitter.com/sebsilbermann)、[Seth Webster](https://twitter.com/sethwebster)、および[Sophie Alpert](https://twitter.com/sophiebits)に感謝します。

読んでいただきありがとうございます。次回の更新でお会いしましょう！